;
~
{ re:
    { id:  're.hi@ionify'
    , of: ['more', 'public', 're', 'sion', 'api']
    , by: ['🙇🏾‍♂️ יהוה 🤲🏾', 'mike🇬🇾👨🏾‍💻🇺🇸lee', 'team✨ionify']
    , on:                     { 200709.8330    : -4}
    , to: {578408073.1110: -8 , 202411123.8330 : -8}
    , at: -0.004
    , do: {conformation:   true, transcription:   true}
    , as: {   sensation: -0.001,    convention: -0.001}
    , is:
        [ "ionify's re.hi@: handled    invocation, "
        +           "sion@: semantic invoked object notation, "
        +      "sensation@: sensing action: active ion."

        , "indicating   an alternate sim: semantic ion member for invocation"
        , "implementing an alternate locally-defined   sim    for invocation"
        ],
      go:
        { meet: 'https://meet.ionify.net/'
        , seek: 'https://seek.ionify.net/'
        , know: 'https://know.ionify.net/'
        , deal: 'https://deal.ionify.net/'
        , help: 'https://help.ionify.net/'
        , test: 'https://github.com/ionify/ionify/blob/public/ions/re.hi.test.js'
        , code: 'https://github.com/ionify/ionify/blob/public/re.hi.js'
        , plan: 'https://plan.ionify.net/'
        , join: 'https://join.ionify.net/'
        , team: 'https://team.ionify.net/'
        },
      it:
        [ "KEEPS sions' re.hi method in case sions' reinitiation's needed"
        , "KNOWS re.hi == 'ionify' means delete sion.valueOf after +sion.ionify"
        , "KNOWS re.hi:true   = hiphop: handled.in.place.handled.on.prototype"
        , "KNOWS re.hi:'name' = hip   : handled.in.place"
        ],
      we:
        [ "note core:do@ & more:logger@ re.hi for ad.hoc with@ name resolution"
        , "note more:sion.re.hi@ because we can ad.hoc sion.re.do@ or ~get it"
        , "will implement invoking a sim implemented elsewhere by 1st ~get.ing it"
        ,
        , "must ..."
        , "will ..."
        , "plan ..."
        , "need ..."
        , "test ..."
        , "want ..."
        , "like ..."
        , "know ..."
        , "care ..."
        , "wish ..."
        , "note ..."
        , "have ..."
        , "keep ..."
        , "dont ..."
        , "wont ..."
        , "cant ..."
        ]
    },

  on:
 '*',
 '*':function
  hi( ion )
    { var method = ion.re && ion.re.hi;
      if(!method)  return //ion is an obi: observable ion & wants to be that 👋🏾

      var hiphop =  false //ion wants to handle its invocation
        ; method === true && (method = 'ionify') && (hiphop = true)

      var via       = hi.with
        , sensing   = via && via.the && via.the.tools.sensible
        , sensible  ={sensible:method, in:ion}
        ; sensing   = sensing && sensing (sensible) || +sensible

      method = ion [method] || method

      if(!sensing)
        { var missing = via.its.missing
        ~ {warn:missing} + {debug: [true, missing, ion.re]}
        ; return
        }

      ion.re.hi   = false   //🙇🏾‍♂️ ion can handle its own invocation so let it
      ion.valueOf = method  //👨🏾‍💻 by setting its invocation sensor as stated.
      Object.isExtensible   (ion) &&//👨🏾‍🏫 configurable | writable false blocks
      Object.defineProperty (ion,'valueOf',{enumerable:false})  //🤭 hip-hop!
    ~ ion                           //⚛️ invoke the ion's handled invocation &
      hiphop && delete ion.valueOf  //🕺🏾 do hip-hop invocation if specified 🎉
    },

  missing
    : "re.hi: handled invocation handler function is missing check debug details"
}
;